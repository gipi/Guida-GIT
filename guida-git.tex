\input macro
\font\commitfn=cmtt10 at 5pt
%\parfillskip 10pt plus 1fil
\parindent=10pt
% capitoli
\line{\capitolofont GIT}
\vfil
\licenza
\eject
\input getting-started
\input comandi
\input workflow
\input informazioni
\input sharing
\input submodule
\input config
\input hooks
\input interfaccie-grafiche
\input low-level

\capitolo Miscellanea

\sezione Installazione non standard on the remote side

Magari sulla macchina remota l'installazione \`e in posizione non banale quindi
per evitare scleri

\iniziacode
$ git [clone || pull] --upload-pack /path/to/git-upload-pack [URL]
|finecode

\sezione Debugging del push

Per qualche oscura ragione potrebbe non funzionare correttamente il push tramite
\code{ssh} e quindi di seguito un metodo molto interessante
\iniziacode
$ echo "ssh -v -v -v $@" > ssh_debug_wrapper
$ GIT_SSH="./ssh_debug_wrapper" git push
|finecode

\sezione Avere permessi per referenza

Nella sezione \url{contrib/hooks/update-paranoid} esiste uno script che permette
di avere un accesso controllato pi\`u finemente di quanto permetta
\code{gitosis}. Trascrivo qui il contenuto della parte di documentazione
contenuta nel file stesso

\iniziacode
Invoked as: update refname old-sha1 new-sha1

This script is run by git-receive-pack once for each ref that the
client is trying to modify.  If we exit with a non-zero exit value
then the update for that particular ref is denied, but updates for
other refs in the same run of receive-pack may still be allowed.

We are run after the objects have been uploaded, but before the
ref is actually modified.  We take advantage of that fact when we
look for "new" commits and tags (the new objects won't show up in
`rev-list --all`).

This script loads and parses the content of the config file
"users/$this_user.acl" from the $acl_branch commit of $acl_git ODB.
The acl file is a git-config style file, but uses a slightly more
restricted syntax as the Perl parser contained within this script
is not nearly as permissive as git-config.

Example:

  [user]
    committer = John Doe <john.doe@example.com>
    committer = John R. Doe <john.doe@example.com>

  [repository "acls"]
    allow = heads/master
    allow = CDUR for heads/jd/
    allow = C    for ^tags/v\\d+$

For all new commit or tag objects the committer (or tagger) line
within the object must exactly match one of the user.committer
values listed in the acl file ("HEAD:users/$this_user.acl").

For a branch to be modified an allow line within the matching
repository section must be matched for both the refname and the
opcode.

Repository sections are matched on the basename of the repository
(after removing the .git suffix).

The opcode abbrevations are:

  C: create new ref
  D: delete existing ref
  U: fast-forward existing ref (no commit loss)
  R: rewind/rebase existing ref (commit loss)

if no opcodes are listed before the "for" keyword then "U" (for
fast-forward update only) is assumed as this is the most common
usage.

Refnames are matched by always assuming a prefix of "refs/".
This hook forbids pushing or deleting anything not under "refs/".


Refnames that start with ^ are Perl regular expressions, and the ^
is kept as part of the regexp.  \\ is needed to get just one \, so
\\d expands to \d in Perl.  The 3rd allow line above is an example.

Refnames that don't start with ^ but that end with / are prefix
matches (2nd allow line above); all other refnames are strict
equality matches (1st allow line).

Anything pushed to "heads/" (ok, really "refs/heads/") must be
a commit.  Tags are not permitted here.

Anything pushed to "tags/" (err, really "refs/tags/") must be an
annotated tag.  Commits, blobs, trees, etc. are not permitted here.
Annotated tag signatures aren't checked, nor are they required.

The special subrepository of 'info/new-commit-check' can
be created and used to allow users to push new commits and
tags from another local repository to this one, even if they
aren't the committer/tagger of those objects.  In a nut shell
the info/new-commit-check directory is a Git repository whose
objects/info/alternates file lists this repository and all other
possible sources, and whose refs subdirectory contains symlinks
to this repository's refs subdirectory, and to all other possible
sources refs subdirectories.  Yes, this means that you cannot
use packed-refs in those repositories as they won't be resolved
correctly.
|finecode


\sezione Creare branch indipendente o commit senza parenti

Per creare un commit chiamato \code{mybranch} senza parenti
(in pratica un branch slegato)
\iniziacode
$ git symbolic-ref HEAD refs/heads/mybranch
$ git rm --cached -r .
$ rm *
$ git commit --allow-empty
|finecode

\input linkografia

\end
